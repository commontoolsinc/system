//! Host binding details for use when instantiating Common Module guests

use std::collections::BTreeMap;

use super::super::bindings::*;

use wasmtime::component::{Resource, ResourceTable};
use wasmtime_wasi::{WasiCtx, WasiView};

// NOTE: This module comes from wasmtime::component::bindgen
use common::data::types::{Reference, Value as BindingValue};
use wasmtime_wasi_http::{WasiHttpCtx, WasiHttpView};

use crate::{InputOutput, Value};

impl From<BindingValue> for Value {
    fn from(value: BindingValue) -> Self {
        match value {
            BindingValue::String(inner) => Value::String(inner),
            BindingValue::Number(inner) => Value::Number(inner),
            BindingValue::Boolean(inner) => Value::Boolean(inner),
            BindingValue::Buffer(inner) => Value::Buffer(inner),
        }
    }
}

impl From<Value> for BindingValue {
    fn from(value: Value) -> Self {
        match value {
            Value::String(inner) => BindingValue::String(inner),
            Value::Boolean(inner) => BindingValue::Boolean(inner),
            Value::Number(inner) => BindingValue::Number(inner),
            Value::Buffer(inner) => BindingValue::Buffer(inner),
        }
    }
}

/// A concrete implementation of an [InputOutput] that facades access to an
/// underlying anymorphic implementation
#[repr(transparent)]
#[derive(Debug)]
pub struct LinkableInputOutput(Box<dyn InputOutput>);

impl From<LinkableInputOutput> for Box<dyn InputOutput> {
    fn from(value: LinkableInputOutput) -> Self {
        value.0
    }
}

impl From<Box<dyn InputOutput>> for LinkableInputOutput {
    fn from(value: Box<dyn InputOutput>) -> Self {
        LinkableInputOutput(value)
    }
}

impl InputOutput for LinkableInputOutput {
    fn read(&self, key: &str) -> Option<Value> {
        self.0.read(key)
    }

    fn write(&mut self, key: &str, value: Value) {
        self.0.write(key, value)
    }

    fn output(&self) -> &BTreeMap<String, Value> {
        self.0.output()
    }
}

#[repr(transparent)]
struct ModuleHostReference(String);

/// A [ModuleHostState] embodies the bindings from a host runtime to that are
/// made available to a guest Common Module. The shape of these bindings are
/// determined by the Common WIT definitions. All traits that represent the
/// substantive implementation of a [ModuleHostState] are generated by
/// [wasmtime::component::bindgen].
pub struct ModuleHostState {
    io: LinkableInputOutput,
    references: ResourceTable,

    view_resources: ResourceTable,
    view_ctx: WasiCtx,

    http_resources: ResourceTable,
    http_ctx: WasiHttpCtx,
}

impl ModuleHostState {
    fn guest_reference_to_host_reference(
        &self,
        reference: Resource<Reference>,
    ) -> Result<&ModuleHostReference, String> {
        let host_resource = Resource::<ModuleHostReference>::new_own(reference.rep());

        self.references
            .get(&host_resource)
            .map_err(|error| format!("{error}"))
    }
}

impl ModuleHostState {
    /// Instantiate the [ModuleHostState] by providing it an implementor of
    /// [InputOutput] that will be made indirectly available to the guest Common
    /// Modules that are instantiated under the [ModuleHostState].
    pub fn new(io: LinkableInputOutput) -> Self {
        ModuleHostState {
            io,
            references: ResourceTable::default(),

            view_resources: ResourceTable::default(),
            view_ctx: WasiCtx::builder().build(),

            http_resources: ResourceTable::default(),
            http_ctx: WasiHttpCtx::new(),
        }
    }

    /// Swap the [ModuleHostState] for the [InputOutput] that was used to
    /// instantiate it.
    pub fn take_io(self) -> LinkableInputOutput {
        self.io
    }
}

impl common::io::state::Host for ModuleHostState {
    fn read(&mut self, name: String) -> Option<Resource<Reference>> {
        debug!("common:io/state.read: {name}");
        self.io.read(&name)?;

        self.references
            .push(ModuleHostReference(name))
            .map_err(|error| error!("Unable to allocate Reference: {error}"))
            .ok()
            .map(|host_reference| Resource::new_own(host_reference.rep()))
    }

    fn write(&mut self, name: String, value: BindingValue) {
        debug!("common:io/state.write: {name}");
        self.io.write(&name, value.into());
    }
}

impl common::data::types::HostReference for ModuleHostState {
    /// Dereference a reference to a value
    /// This call is fallible (for example, if the dereference is not allowed)
    /// The value may be none (for example, if it is strictly opaque)
    fn deref(&mut self, resource: Resource<Reference>) -> Result<Option<BindingValue>, String> {
        let ModuleHostReference(key) = self.guest_reference_to_host_reference(resource)?;
        Ok(self.io.read(key).map(|value| value.into()))
    }

    fn drop(&mut self, rep: Resource<Reference>) -> wasmtime::Result<()> {
        let host_resource = Resource::<ModuleHostReference>::new_own(rep.rep());
        self.references.delete(host_resource)?;
        Ok(())
    }
}

impl common::data::types::Host for ModuleHostState {}

impl WasiView for ModuleHostState {
    fn table(&mut self) -> &mut ResourceTable {
        &mut self.view_resources
    }

    fn ctx(&mut self) -> &mut WasiCtx {
        &mut self.view_ctx
    }
}

impl WasiHttpView for ModuleHostState {
    fn ctx(&mut self) -> &mut wasmtime_wasi_http::WasiHttpCtx {
        &mut self.http_ctx
    }

    fn table(&mut self) -> &mut ResourceTable {
        &mut self.http_resources
    }
}
